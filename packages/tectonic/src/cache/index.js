// @flow

import { Map } from 'immutable';
import {
  UPDATE_DATA,
  DELETE_DATA,
} from '../reducer';
import Model from '../model';
import Query from '../query';
import SourceDefinition from '../sources/definition';
import Provider from '../sources/provider';
import Status from '../status/status';
import {
  RETURNS_ITEM,
  RETURNS_LIST,
  GET,
  DELETE,
} from '../consts';
import type {
  ModelData,
  ModelCollection,
} from '../consts';
import type {
  StatusOpts,
} from '../status/status';

/**
 * Cache represents an abstraction over redux' store for saving and reading
 * data.
 *
 * TODO: Per-model cache rules
 * TODO: custom cache rules and predicates
 */
export default class Cache {

  /**
   * store holds a reference to the redux store
   */
  store: Object;

  constructor(store: Object) {
    if (store === undefined || store.dispatch === undefined || store.getState === undefined) {
      throw new Error('Cache must be defined with a redux store');
    }
    this.store = store;
  }

  /**
   * storeQuery is called from the resolver after a successful query to store
   * data in the reducer for future components.
   *
   * @param Query
   * @param SourceDefinition
   * @param {(object|array)} - array containing list of data, object of
   * poylmorphic data or an object of a single API response. If the API returned
   * 204 this should be undefined.
   * @param Date - date at which this data should expire
   */
  storeQuery(query: Query, sourceDef: SourceDefinition, apiResponse: Object | Array<Object>, expires: Date = new Date()) {
    if (query.queryType === DELETE) {
      // Add the ID of this model to the delete blacklist
      if (query.modelId === undefined || query.modelId === null) {
        throw new Error('unknown model ID during DELETE in query: ', query);
      }

      this.store.dispatch({
        type: DELETE_DATA,
        payload: {
          query,
          model: query.model,
          modelName: query.model.modelName,
          modelId: `${query.modelId}`, // modelIds should always be strings in reducers
        },
      });
      return;
    }

    if (!apiResponse) {
      // Probably a 204 - we can back out safely.
      return;
    }

    const data = this.parseApiData(query, sourceDef, apiResponse, expires);

    // Store the parsed data and the IDs generated by said query within our
    // state
    this.store.dispatch({
      type: UPDATE_DATA,
      payload: {
        data,
        query,
        expires,
      },
    });
  }

  /**
   * parseApiData takes an entire API response and formats each model's data in
   * the storage format to store within redux.
   *
   * The return is formatted like so:
   * {
   *   [model.modelName]: {
   *     [id]: {
   *       data: {...},
   *       cache: {...},
   *     },
   *     ...
   *   },
   *   ...
   * }
   *
   * @param Query
   * @param SourceDefinition
   * @param object
   * @param Date  timestamp to add within cache, defaults to now. Used in
   * testing
   * @return object
   */
  parseApiData(query: Query, sourceDef: SourceDefinition, apiResponse: Object | Array<Object>, expires: Date = new Date()): ModelCollection {
    const toStore: ModelCollection = {};

    // The following cases may be encountered when parsing an API response from
    // a source definition:
    //
    // 1. Multiple providers, returns an array [FAIL]
    // 2. Multiple providers, returns an object [OK - each key represents
    //    a single provider's data]
    // 3. Single provider, returns an array [OK - list]
    // 4. Single provider, returns an object [OK - item]

    sourceDef
      .providers
      .defs
      .forEach((def) => {
        const { key, provider } = def;
        let modelData;

        // If this source def has multiple providers and the provider key is
        // null or undefined throw an error. You need to define
        if (sourceDef.isPolymorphic() && (key === null || key === undefined)) {
          throw new Error('Error attempting to parse model data with no key', sourceDef, apiResponse);
        }

        if (sourceDef.isPolymorphic()) {
          // Fail as described in the scenario above; this polymorphic API
          // response needs an object
          if (Array.isArray(apiResponse)) {
            throw new Error('Unexpected array response from polymorphic API definition', sourceDef, apiResponse);
          }
          modelData = this.parseProvider(query, provider, provider.model, apiResponse[key], expires);
        } else {
          modelData = this.parseProvider(query, provider, provider.model, apiResponse, expires);
        }

        toStore[provider.model.modelName] = modelData;
      });

    return toStore;
  }

  /**
   * parseProvider produces an object we save in the redux store for each
   * Provider instance within a sourceDefinition.
   *
   * For a single Returns instance this will produce an object as follows:
   * {
   *   [id]: {
   *     data: {...},
   *     cache: {...},
   *   }
   * }
   *
   * If the model of the data we're passing matches the queried for model, this
   * also adds the model IDs to the query (each query can specify a SINGLE
   * model). This allows us to cache the model IDs returned for a given query,
   * which aids in lookups.
   *
   * For example, if the query was for a list of Posts and the endpoint returned
   * the User AND the posts, this would add all returned post IDs to the query
   * only.
   *
   * @param Query   Query so we can add the IDs of returned data to the query
   * for caching
   * @param Provider
   * @param Model
   * @param object API data
   * @param Date  timestamp to add within cache, defaults to now. Used in
   * testing
   * @return object
   *
   * TODO: Return type for this function
   */
  parseProvider(query: Query, provider: Provider, model: Class<Model>, apiResponse: Object | Array<Object>, expires: Date): ModelData {
    if (provider.returnType === RETURNS_LIST && !Array.isArray(apiResponse)) {
      throw new Error('Data for returning a list must be an array', apiResponse);
    }

    if (provider.returnType === RETURNS_ITEM && Array.isArray(apiResponse)) {
      throw new Error('Data for returning an item must be an object', apiResponse);
    }

    let resp: Array<Object>;
    if (Array.isArray(apiResponse)) {
      resp = apiResponse;
    } else {
      // standardize to list so we deal with one case. laziness meeans love
      // homie
      resp = [apiResponse];
    }

    // Take each instance of model data from the API response and save it in an
    // object to store in redux.
    //
    // We store things in a tree of modelName => id => { data: ..., cache: ...
    // }.
    //
    // modelData will contain a map of IDs to data and cache objects
    const data: ModelData = resp.reduce((toStore: ModelData, item: Object) => {
      if (typeof item !== 'object') {
        throw new Error('Unable to process data from API; data is not an object', item);
      }

      const { idField } = model;
      const id = item[idField];

      if (typeof id !== 'string' && typeof id !== 'number') {
        throw new Error('Unable to process data from API; data is missing the ID attribute as a string or number', item);
      }

      // Each query needs to store the IDs of the model it queried for.
      // This is handled in the reducer when UPDATE_DATA is called via
      // storeQuery.
      if (query.model === model) {
        // Make sure the ID is a string
        query.returnedIds.add(`${id}`);
      }

      toStore[id] = {
        data: item,
        // Each particular model stores its expiry expires which is taken from
        // response headers.  In the future this will let us determine whether
        // a query can be skipped based on the IDs it expects and each model's
        // cache information
        cache: {
          expires,
        },
      };

      return toStore;
    }, {});

    return data;
  }

  /**
   * Returns the IDs returned by this query if it's cached in
   * state/queriesToIds. If the data is in queriesToIds we've *definitely*
   * called this query before; we only need to determine whether the cached data
   * is stale.
   *
   */
  cachedQueryIds(query: Query, state: Map<*, *>): Set<*> {
    return state.getIn(['queriesToIds', query.hash()], new Set());
  }

  /**
   * getQueryData inspects the given state for the current model for the
   * necessary data and returns it if all requirements are met.
   *
   * @param Query  Query, which must have a filled .returnedIds
   * @param Map    Tectonic's reducer state (store.getState().tectonic)
   * @return tuple:[data,bool] Data and bool indicating whether item was in
   * cache
   *
   * TODO: flow return type for tuple
   */
  getQueryData(query: Query, state: Map<*, *>) {
    // Non-GET queries such as post, put, delete, patch should never have cached
    // data. This ensures that any resolver retries the data, as a resolver
    // should ONLY skip the request if this returns a tuple with false
    // indicating it's not in the cache.
    if (query.queryType !== GET) {
      return [undefined, false];
    }

    const returnedIds = this.cachedQueryIds(query, state);

    // No IDs were returned when we queried for this item
    if (returnedIds.size === 0) {
      // ensure we return a consistent default; RETURNS_ITEM will always use
      // a blank model but we need to return a list for RETURNS_LIST.
      const returns = (query.returnType === RETURNS_LIST) ? [] : undefined;
      return [returns, true];
    }

    if (query.returnType === RETURNS_ITEM && returnedIds.size !== 1) {
      throw new Error(`Invalid returnedIds length for a single item call: ${returnedIds.size}`);
    }

    const { modelName } = query.model;

    if (query.returnType === RETURNS_ITEM) {
      // XXX tidy this pluck
      const map = state.getIn(['data', modelName, returnedIds.values().next().value]);
      const data = this.processCachedModelMap(map);
      if (data === false) {
        return [undefined, false];
      }
      return [data, true];
    }

    // This returns many items in a list; iterate through all of the returned
    // IDs and fetch our data
    const data = Array.from(returnedIds).map(
      id => this.processCachedModelMap(state.getIn(['data', modelName, id]))
    );

    if (data.some(item => item === false)) {
      return [data.filter(Boolean), false];
    }

    return [data, true];
  }

  /**
   * processCachedModelMap validates a model instance's data plucked from the
   * cache.
   *
   * It returns false if the data has expired, doesn't exist or has been
   * deleted, otherwise it returns the model instance data itself
   *
   * @param Map
   * @return Object
   */
  processCachedModelMap(map: ?Map<*, *>): Object | boolean {
    if (map === undefined || map === null) {
      return false;
    }

    const { data, cache, deleted } = map.toObject();

    if (cache !== undefined && cache.expires !== undefined) {
      const { expires } = cache;
      // Check the expires header to see if the model is out of date.
      // Fudge the expiry date by +1 second to avoid timing issues.
      // XXX should we store expiry per-model or per query? This might not be
      // necessary
      if (expires.setSeconds(expires.getSeconds() + 1) < new Date()) {
        return false;
      }
    }

    if (deleted === true) {
      return false;
    }
    return data.toJS();
  }

  getQueryStatus(query: Query, state: Map<*, *>): Status {
    const status = state.getIn(['status', query.hash()], ({}: StatusOpts));
    return new Status(status);
  }

  /**
   * Returns whether a query has expired, given tectonic state.
   * If there is no expiry time for a query this will always return true.
   *
   * @return bool
   */
  hasQueryExpired(query: Query, state: Map<*, *>): boolean {
    return state.getIn(['queriesToExpiry', query.hash()], 0) < new Date();
  }

}
